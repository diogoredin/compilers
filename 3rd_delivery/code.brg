%{
#include <stdio.h>
#include "node.h"
#include "tabid.h"
#include "y.tab.h"
#include "postfix.h"

extern FILE *yyout;
static int lbl;
static char *mklbl(int n);
static char *mkfunc(char *s);
static void outstr(char *s);
extern int yyerror(char *s);
%}

%include "y.tab.h"

%term ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' LT='<' GT='>' EQU='=' AND='&' OR='|'
%term FUNC='(' END=';' COM=',' BLCK='{' INDEX='['

%start prog
%%

%! Program, Functions and Declarations
prog: decl 1 					{}
decl: func 1 					{}
func: FUNC(blockp,params) 1		{}
params: param 1 				{}
params: COM(params,param) 1 	{}
param: PARAM(type,ID) 1			{}
type: INTEGER 1 				{}
type: STRING 1 					{}
type: NUMBER 1 					{}
blockp: block 1 				{}
block: NIL 1 					{}

%! Block and base
block: BLCK(list,decls) 1		{}
list: base 1					{}
list: END(list,base) 1			{}
decls: NIL 1					{}
decls: END(decls,param) 1		{}
base: VOID 1 					{}
base: NIL 1 					{}
base: expr 1					{ fprintf(yyout, pfTRASH, pfWORD); }

%! Arguments and expressions
args: COM(expr,args) 1			{}
args: COM(expr,NIL) 1			{}
expr: CALL(ID,args) 1			{ fprintf(yyout, pfCALL, mkfunc(LEFT_CHILD(p)->value.s)); if (RIGHT_CHILD(p)->place) fprintf(yyout, pfTRASH, (int)(pfWORD*(RIGHT_CHILD(p)->place))); }
expr: STR 1						{ lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl)); }
expr: INT 1						{ fprintf(yyout, pfIMM, p->value.i); }
expr: REAL 1					{}

%! lvalues
expr: PTR(lval)               	{ /* No code, but keep PTR to avoid missing LOADs */ }
lval: INDEX(lvec,expr) 1      	{ fprintf(yyout, pfIMM pfMUL pfADD, pfWORD); }
lvec: lval 1                  	{ fprintf(yyout, pfLOAD); }
lval: LOCAL 1                 	{ fprintf(yyout, pfADDR, p->value.s); }
lval: ID 1                    	{ fprintf(yyout, pfLOCAL, p->user); /* position calculated in yacc */ }

%! Atribution
assign: expr 1                	{ fprintf(yyout, pfDUP); }
expr: ATR(assign,lval) 1		{ fprintf(yyout, pfSTORE); }

%! Operations with Expressions
expr: ADD(expr,expr) 1        	{ fprintf(yyout, pfADD); }
expr: SUB(expr,expr) 1        	{ fprintf(yyout, pfSUB); }
expr: MUL(expr,expr) 1        	{ fprintf(yyout, pfMUL); }
expr: DIV(expr,expr) 1        	{ fprintf(yyout, pfDIV); }
expr: MOD(expr,expr) 1        	{ fprintf(yyout, pfMOD); }
expr: LT(expr,expr) 1        	{ fprintf(yyout, pfLT); }
expr: GT(expr,expr) 1         	{ fprintf(yyout, pfGT); }
expr: GE(expr,expr) 1         	{ fprintf(yyout, pfGE); }
expr: LE(expr,expr) 1         	{ fprintf(yyout, pfLE); }
expr: NE(expr,expr) 1         	{ fprintf(yyout, pfNE); }
expr: EQU(expr,expr) 1        	{ fprintf(yyout, pfEQ); }
expr: AND(and,expr) 1         	{ fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and: expr 1                  	{ p->place = ++lbl; fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr: OR(or,expr) 1           	{ fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or:	expr 1                    	{ p->place = ++lbl; fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }

%%

extern char **yynames;

static int sameVar(NODEPTR_TYPE p) {
	return strcmp(LEFT_CHILD(p)->value.s, LEFT_CHILD(RIGHT_CHILD(p))->value.s) ? 0x7fff : 2;
}

static int data(int t, char *s, int a, int user) {
	if (s) fprintf(yyout, pfLABEL pfINTEGER, s, 0);
	return 1;
}

static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "_i%d", n);
	return strdup(buf);
}

static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}

static void outstr(char *s) {
	while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
	fprintf(yyout, pfCHAR, 0);
}

/******************************************************************
*
*	CODE PRODUCTION FOR BURG (called on YACC)
*
*******************************************************************/

/* Original evaluation */
void evaluate(Node *p) {
	extern int trace, errors;

	if (errors) return;
	if (trace) printNode(p, stdout, yynames);

	fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_entry", pfFUNC, "_entry");

	yyselect(p);
	fprintf(yyout, pfRET pfDATA);

	IDevery(data,0);
	fprintf(yyout, pfEXTRN pfEXTRN pfEXTRN pfEXTRN, "_prints", "_printi", "_println", "_readi");
}

/* Function evaluation */
void functionEvaluate(char *name, int enter, Node *body) {

	int i;
	int overflow = 32;
	int IDPosition = IDfind(name,0);

	/* Print Tree of function */
	extern int trace;
	printNode(body, stdout, yynames);

	/* Stack overflow */
	if ( IDPosition > overflow || IDPosition == overflow ) {
		IDPosition = IDPosition - overflow;
	}

	if ( LEFT_CHILD(body)->value.s == 0 || LEFT_CHILD(body)->attrib == NIL ) {
		fprintf(yyout, pfEXTRN, mkfunc(name));

	} else {

		/* ENTRY Function */
		if (strcmp(name, "entry") == 0) {
			fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "_entry", pfFUNC, "_entry", enter);

		/* OTHER Functions */
		} else {
			fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, name, pfFUNC, name, enter);
		}

		/* yyselect inits instruction selection for rest of the tree */
		if (yyselect(body) == 1) {
			yyerror("No match found.");
		}

		/* Return functions */
		if (IDPosition != 0) {
			fprintf(yyout, pfLOCAL pfLOAD pfPOP pfLEAVE pfRET, -4); /* -4 assumes int */
		} else {
			fprintf(yyout, pfLEAVE pfRET);
		}

	}
}

/* Declare evaluation */
void declareEvaluate(char *name, Node *value) {
  int tipo = IDfind(name, 0);

  if (tipo == 0 || value == 0)
    fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE pfTEXT, name, 4);
  else {
    if ((tipo & 0x15) >= 9) fprintf(yyout, pfRODATA);    //CONS
    else fprintf(yyout, pfDATA);

    fprintf(yyout, pfALIGN);

    if ((tipo & 0x31) >= 17){                            //PUBLIC
      if ((tipo & 0x3) == 1) fprintf(yyout, pfGLOBL, name, pfINTEGER);
      else if ((tipo & 0x3) == 2) fprintf(yyout, pfGLOBL, name, pfSTR);
    }

    fprintf(yyout, pfLABEL, name);

    if ((tipo & 0x7) >= 5) fprintf(yyout, pfID, value->value.s);  //PTR
    else if ((tipo & 0x3) == 1) fprintf(yyout, pfINTEGER, value->value.i);
    else if ((tipo & 0x3) == 1) fprintf(yyout, pfSTR, value->value.s);

    fprintf(yyout, pfTEXT);
  }
}
