%{
#include <stdio.h>
#include "node.h"
#include "tabid.h"
#include "y.tab.h"
#include "postfix.h"

extern FILE *yyout;
static int lbl;
static char *mklbl(int n);
static char *mkfunc(char *s);
static void outstr(char *s);
extern int yyerror(char *s);
%}

%include "y.tab.h"

%term END=';' ASSIGN='=' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' LT='<' GT='>' 
%term FUNC='(' COM=',' BLCK='{'

%start prog
%%

%! Programa, Funcoes e Declaracoes
prog: decl 1 					        {}
decl: func 1 					        {}
func: FUNC(blocop,params) 1 	{}
params: param 1 				      {}
params: COM(params,param) 1 	{}
param: PARAM(tipo,ID) 1 		  {}
tipo: INTEGER 1 				      {}
tipo: STRING 1 					      {}
tipo: NUMBER 1 					      {}
blocop: bloco 1 				      {}
bloco: NIL 1 					        {}

%! Bloco e Base
bloco: BLCK(list,decls) 1 		{}
list: base 1					        {}
list: END(list,base) 1			  {}
decls: NIL 1					        {}
decls: END(decls,param) 1		  {}
base: VOID 1 					        {}
base: NIL 1 					        {}
base: expr 1					        {}

%! Argumentos e Expressoes
args: COM(args,expr) 1			  {}
args: COM(NIL,expr) 1			    {}
expr: CALL(ID,args) 1			    { fprintf(yyout, pfCALL, mkfunc(LEFT_CHILD(p)->value.s)); if (RIGHT_CHILD(p)->place) fprintf(yyout, pfTRASH, (int)(pfWORD*(RIGHT_CHILD(p)->place))); }
expr: STR 1						        { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl)); }
expr: INT 1						        {}
expr: REAL 1					        {}
expr: ATR(expr,lv) 1			    {}
lv: ID 1						          {}
lv: LOCAL 1						        {}

%%

extern char **yynames;

static int sameVar(NODEPTR_TYPE p) {
	return strcmp(LEFT_CHILD(p)->value.s, LEFT_CHILD(RIGHT_CHILD(p))->value.s) ? 0x7fff : 2;
}

static int data(int t, char *s, int a, int user) {
	if (s) fprintf(yyout, pfLABEL pfINTEGER, s, 0);
	return 1;
}

static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "_i%d", n);
	return strdup(buf);
}

static char *mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}

static void outstr(char *s) {
	while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
	fprintf(yyout, pfCHAR, 0);
}

/******************************************************************
*
*	CODE PRODUCTION FOR BURG (called on YACC)
*
*******************************************************************/

/* Original evaluation */
void evaluate(Node *p) {
	extern int trace, errors;

	if (errors) return;
	if (trace) printNode(p, stdout, yynames);

	fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_entry", pfFUNC, "_entry");
	
	yyselect(p);
	fprintf(yyout, pfRET pfDATA);

	IDevery(data,0);
	fprintf(yyout, pfEXTRN pfEXTRN pfEXTRN pfEXTRN, "_prints", "_printi", "_println", "_readi");
}

/* Function evaluation */
void functionEvaluate(char *name, int enter, Node *body) {

  int i;
  int tipo = IDfind(name, 0);

  if (tipo >= 32) 
      tipo -= 32;

  extern int trace;
  printNode(body, stdout, yynames);

  if ( LEFT_CHILD(body)->value.s == 0 || LEFT_CHILD(body)->attrib == NIL) {
	  fprintf(yyout, pfEXTRN, mkfunc(name));
  } else {
    if (strcmp(name, "entry") == 0) // para a funcao entry
      fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, "_entry", pfFUNC, "_entry", enter);
    else
    fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, name, pfFUNC, name, enter);
    if (yyselect(body) == 1) yyerror("No match for syntactic tree.");
    if(tipo != 0)
    { fprintf(yyout, pfLOCAL pfLOAD pfPOP pfLEAVE pfRET, -4);}

    else fprintf(yyout, pfLEAVE pfRET); /* just in case there is no 'return' */
  }
}

/* Declare evaluation */
void declareEvaluate(char *name, Node *value) {
  int tipo = IDfind(name, 0);

  if (tipo == 0 || value == 0)
    fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE pfTEXT, name, 4);
  else {
    if ((tipo & 0x15) >= 9) fprintf(yyout, pfRODATA);    //CONS
    else fprintf(yyout, pfDATA);

    fprintf(yyout, pfALIGN);

    if ((tipo & 0x31) >= 17){                            //PUBLIC
      if ((tipo & 0x3) == 1) fprintf(yyout, pfGLOBL, name, pfINTEGER);
      else if ((tipo & 0x3) == 2) fprintf(yyout, pfGLOBL, name, pfSTR);
    }

    fprintf(yyout, pfLABEL, name);

    if ((tipo & 0x7) >= 5) fprintf(yyout, pfID, value->value.s);  //PTR
    else if ((tipo & 0x3) == 1) fprintf(yyout, pfINTEGER, value->value.i);
    else if ((tipo & 0x3) == 1) fprintf(yyout, pfSTR, value->value.s);

    fprintf(yyout, pfTEXT);
  }
}
